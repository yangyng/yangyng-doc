## JVM 内存 ##
1. 查看是内存泄露还是内存溢出
2. 对于内存泄露的情况 使用工具查询泄露对象到GC Roots的引用链 查看原因 对此作出解决方案	如果是内存溢出	
3. 内存泄露  检查jvm 参数 -Xmx 与 -Xms	根据机器物理内存状况查看是否可以把参数调大	从代码方面考虑 是否存在某些对象生命周期过长 持有状态的时间过长 
	

（1）**堆溢出 堆中存放的对象实例**
	
	堆内存　分为年轻代和老年代　
	年轻代包括一个　eden　和两个Survivor

	创建对象时　内存的申请过程
	JVM尝试在Eden中分配创建对象所需的内存
	内存大小足够　下一步
	内存大小不够时　
	JVM启用YoungGC将Eden中不活跃对象释放　如果空间仍然不够
	将部分Eden中的活跃对象放入Survivor
	OLD区内存够时　　将Survivor中的活跃对象放入OLD否则不动
	OLD区内存不够时　进行 FULL GC
	FULL GC依然内存不够　则无法创建对象　抛出内存溢出
		
	
（2）**栈溢出**

	JVM中的虚拟机栈和本地方法栈 栈容量由 -Xss 参数设置
	1 线程请求的栈深度大于虚拟机所允许的最大深度 抛出 StackOverflowError 异常
	2 虚拟机在扩展栈是无法申请足够内存空间 抛出 OutOfMemoryError 异常
	
	针对第二种情况 
	减少线程数量 
	减少最大堆和减少线程中栈容量来换取更多线程
	
（3）**直接内存溢出**

	直接内存默认大小和java堆最大值一样
	可以考虑是不是程序中使用NIO
	
## JVM调优 ##
　

（１）响应时间优先　吞吐量优先　设置大　垃圾收集　并行进行　　

	
	